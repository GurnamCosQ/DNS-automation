name: Dispatch DNS Create/Update to tf-security

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: read

jobs:
  dispatch:
    if: contains(join(github.event.issue.labels.*.name, ','), 'dns')
    runs-on: ubuntu-latest

    steps:
      - name: Debug event
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "issue_number=${{ github.event.issue.number }}"
          echo "issue_title=${{ github.event.issue.title }}"

      - name: Build payloads from Issue Form
        id: build
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || "";

            // --- helpers ---
            function section(label) {
              const esc = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const rx = new RegExp(`(^|\\r?\\n)###\\s*${esc}\\s*\\r?\\n([\\s\\S]*?)(?=\\r?\\n###\\s|$)`, 'i');
              const m = body.match(rx);
              let v = (m && m[2].trim()) || "";
              return v;
            }
            function stripMd(s) {
              if (!s) return "";
              return String(s)
                // keep fenced content; drop the fences (and optional language tag)
                .replace(/```(?:[^\n]*\n)?([\s\S]*?)```/g, "$1")
                // bold **text** -> text
                .replace(/\*\*(.*?)\*\*/g, "$1")
                // inline code `text` -> text
                .replace(/`([^`]+)`/g, "$1")
                // italic *text* -> text 
                .replace(/\*(.*?)\*/g, "$1")
                // strikethrough ~~text~~ -> text (doesn't affect single ~ like ~all)
                .replace(/~~(.*?)~~/g, "$1")
                .trim();
            }
            function emptyish(s) {
              const raw = stripMd(s);
              const v = (raw == null ? "" : String(raw)).trim();
              if (!v) return true;
              // handle GitHub Issue Formsâ€™ italicized sentinel: _No response_
              const plain = v.replace(/^_+|_+$/g, "").trim().toLowerCase();
              return ["no response","none","n/a","na","null"].includes(plain);
            }
            function unfence(s) {
              if (!s) return s;
              const lines = s.split(/\r?\n/);
              if (lines[0] && lines[0].startsWith("```")) lines.shift();
              while (lines.length && lines[lines.length-1].trim() === "```") lines.pop();
              return lines.join("\n").trim();
            }
            function linesOf(s) {
              return (unfence(s) || "")
                .split(/\r?\n/)
                .map(t => stripMd(t))
                .filter(t => !emptyish(t));
            }
            function ensureDot(s) {
              if (!s) return s;
              return s.endsWith(".") ? s : s + ".";
            }
            function fqdnName(zone, name) {
              const z = ensureDot(stripMd(zone || ""));
              const n = stripMd(name || "");
              if (!n) return n;
              if (n.endsWith(".")) return n;          // already FQDN
              if (n.includes(".")) return n + ".";    // looks FQDN but missing dot
              return n + "." + z;                     // relative -> append zone
            }

            // --- gather inputs ---
            const action      = (stripMd(section("Action")) || "create").toLowerCase();
            const zoneRaw     = section("Zone (must end with a dot)") || section("Zone") || "";
            const nameInput   = section("Record name (relative or FQDN)") || section("Record name") || "";
            const currentType = (stripMd(section("Type (CURRENT type for updates)") || section("Type") || "")).toUpperCase();
            const variant     = (stripMd(section("Variant (create) / New variant (update, optional)") || section("Record variant") || "standard")).toLowerCase();

            const ttlRaw      = stripMd(section("TTL (seconds)") || section("TTL") || "");
            const values      = linesOf(section("Values (one per line)") || section("Values"));

            const alias_target  = stripMd(section("Alias target DNS name"));
            const alias_zone_id = stripMd(section("Alias target hosted zone ID"));
            const alias_eth_raw = stripMd(section("Evaluate target health"));
            const alias_eth     = /^true$/i.test(alias_eth_raw) ? true : /^false$/i.test(alias_eth_raw) ? false : null;

            const snow_id     = stripMd(section("SNOW Request/Task ID"));

            // update-only fields
            const new_name_raw   = section("New record name (optional, update)");
            const new_type_raw   = section("New type (optional, update)");
            const new_ttl_raw    = section("New TTL (optional, update)");
            const new_values     = linesOf(section("New values (optional, update)"));

            const new_alias_target  = stripMd(section("New alias target (optional, update)"));
            const new_alias_zone_id = stripMd(section("New alias hosted zone ID (optional, update)"));
            const new_alias_eth_raw = stripMd(section("New alias evaluate_target_health (optional, update)"));

            // NEW: mode for update records behaviour
            const mode_raw  = stripMd(section("Mode (update records behaviour)"));
            let value_mode  = "replace";
            if (/^append$/i.test(mode_raw)) {
              value_mode = "append";
            }

            // normalize names
            const zone = stripMd(zoneRaw);
            const fqdn = fqdnName(zone, nameInput);

            // CREATE payload
            const createPayload = {
              action: "create",
              zone: ensureDot(zone),
              name: fqdn,
              type: currentType,
              variant: variant || "standard",
              snow_id
            };
            if (createPayload.variant === "alias") {
              if (!emptyish(alias_target))  createPayload.alias_target = ensureDot(alias_target);
              if (!emptyish(alias_zone_id)) createPayload.alias_zone_id = alias_zone_id;
              if (alias_eth !== null)       createPayload.alias_eth = alias_eth;
            } else {
              if (/^\d+$/.test(ttlRaw)) createPayload.ttl = parseInt(ttlRaw, 10);
              if (values.length) createPayload.values = values;
            }

            // UPDATE spec Payload
            const changes = {};
            const new_name = emptyish(new_name_raw) ? "" : stripMd(new_name_raw);
            const new_type = emptyish(new_type_raw) ? "" : stripMd(new_type_raw).toUpperCase();
            const new_ttl  = emptyish(new_ttl_raw)  ? "" : stripMd(new_ttl_raw);

            if (new_name) changes.name = fqdnName(zone, new_name);
            if (new_type) changes.type = new_type;
            if (/^\d+$/.test(new_ttl)) changes.ttl = parseInt(new_ttl, 10);
            if (new_values && new_values.length) changes.records = new_values;

            // switching/setting alias on update
            const anyNewAlias = !!(new_alias_target || new_alias_zone_id || new_alias_eth_raw);
            if (anyNewAlias) {
              const alias = {};
              if (!emptyish(new_alias_target))  alias.name = ensureDot(new_alias_target);
              if (!emptyish(new_alias_zone_id)) alias.zone_id = new_alias_zone_id;
              if (!emptyish(new_alias_eth_raw)) alias.evaluate_target_health = /^true$/i.test(new_alias_eth_raw);
              if (Object.keys(alias).length) changes.alias = alias;
            }

            const updateSpec = {
              zone: ensureDot(zone),
              name: fqdn,               // CURRENT name
              type: currentType,        // CURRENT type
              snow_id,
              value_mode,               // <-- new: replace/append from the form
              changes
            };

            // validation
            const missing = [];
            if (!snow_id) missing.push("snow_id");
            if (!zone) missing.push("zone");
            if (!nameInput) missing.push("name");
            if (!currentType) missing.push("type");

            if (action === "create") {
              if (createPayload.variant === "alias") {
                if (!createPayload.alias_target)  missing.push("alias_target");
                if (!createPayload.alias_zone_id) missing.push("alias_zone_id");
              } else if (!createPayload.values?.length) {
                missing.push("values");
              }
            } else if (action === "update") {
              if (!Object.keys(changes).length) {
                missing.push("at least one change (new_* or new alias fields)");
              }
            }

            if (missing.length) {
              core.setFailed("Missing required fields: " + missing.join(", "));
              core.info("Raw body below for debugging:");
              core.info(body);
              return;
            }

            core.setOutput("action", action);
            core.setOutput("payload_json", JSON.stringify(createPayload));
            core.setOutput("spec_json", JSON.stringify(updateSpec));

      - name: Dispatch to tf-security (CREATE)
        if: steps.build.outputs.action == 'create'
        uses: actions/github-script@v7
        env:
          PAYLOAD_JSON: ${{ steps.build.outputs.payload_json }}
        with:
          github-token: ${{ secrets.TFSEC_WORKFLOW_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'tf-security',
              workflow_id: 'dns-create-main.yml',
              ref: 'main',
              inputs: { payload_json: process.env.PAYLOAD_JSON }
            });

      - name: Dispatch to tf-security (UPDATE)
        if: steps.build.outputs.action == 'update'
        uses: actions/github-script@v7
        env:
          SPEC_JSON: ${{ steps.build.outputs.spec_json }}
        with:
          github-token: ${{ secrets.TFSEC_WORKFLOW_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'tf-security',
              workflow_id: 'dns-update.yml',   // change if your filename differs
              ref: 'main',
              inputs: { spec_json: process.env.SPEC_JSON }
            });
